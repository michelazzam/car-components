name: 🚀 CI Release

# This workflow is responsible for:
# 1. Building and packaging the application for Windows
# 2. Creating a new GitHub release with the packaged executable
# 3. Generating and uploading update manifest for auto-updates

# Trigger on every push to main
on:
  push:
    branches: [ main ]

jobs:
  release:
    name: Build & Release
    runs-on: windows-latest
    permissions:
      contents: write    # needed to create releases & upload assets
    steps:
      # Step 1: Clone the repository
      - name: 📥 Checkout code
        uses: actions/checkout@v3

      # Step 1.5: Check if release already exists
      - name: 🔍 Check existing release
        id: check_release
        run: |
          # Get version from projects.json for car-components project (our source of truth)
          $VERSION = node -p "require('./config/projects.json')['car-components'].version"
          echo "version=$VERSION" >> $env:GITHUB_OUTPUT
          
          # Try to fetch the release
          $response = try {
            $tag = "v${VERSION}"
            $url = "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tag"
            $headers = @{
              "Accept" = "application/vnd.github.v3+json"
              "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            }
            Invoke-RestMethod -Uri $url -Headers $headers -Method Get
            "true"
          } catch {
            if ($_.Exception.Response.StatusCode -eq 404) {
              "false"
            } else {
              throw
            }
          }
          
          if ($response -eq "true") {
            echo "::error::Release v${VERSION} already exists! Please increment the version in config/projects.json for the car-components project"
            exit 1
          }
          echo "✅ No existing release found for v${VERSION}"

      # Add this right after the checkout step and before the Node.js setup
      # Step 1.6: Verify secrets
      - name: 🔍 Verify required secrets
        run: |
          # Check if secrets exist (this won't print the actual values)
          if ([string]::IsNullOrEmpty("${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}")) {
            echo "❌ TAURI_SIGNING_PRIVATE_KEY is not set!"
            exit 1
          } else {
            echo "✅ TAURI_SIGNING_PRIVATE_KEY is set"
          }

      # Step 2: Setup Node.js environment for building client and server
      - name: ⚙️ Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      # Step 3: Setup Rust for Tauri (desktop app framework)
      - name: 🦀 Setup Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: x86_64-pc-windows-msvc  # Windows-specific target
          override: true

      # Step 4: Install all project dependencies (root, client, and server)
      - name: 📦 Install dependencies
        run: |
          npm ci
          npm ci --prefix client
          npm ci --prefix server

      # Step 5: Build and package the server application
      # This step compiles the NestJS server and packages it into a Windows executable
      - name: 🏗️ Build server and package
        run: |
          cd server
          npm run build
          npm run pkg:win  # Creates standalone Windows executable
          cd ..

      # Step 6: Build the Next.js client application
      - name: 🏗️ Build client
        run: npm run build:client

      # Step 7: Setup code signing for the Tauri application
      # This ensures the Windows app is properly signed for security
      - name: 🔐 Setup Tauri signing
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          # Create .tauri directory
          New-Item -Path "src-tauri\.tauri" -ItemType Directory -Force
          
          # Write the key file without any encoding transformation
          [System.IO.File]::WriteAllText(
            "$(Get-Location)\src-tauri\.tauri\myapp.key",
            $env:TAURI_SIGNING_PRIVATE_KEY,
            [System.Text.Encoding]::UTF8
          )
          
          # Verify the key file exists and has content
          if (!(Test-Path "src-tauri\.tauri\myapp.key")) {
            echo "❌ Key file was not created!"
            exit 1
          }
          
          # Read the key file without any encoding transformation
          $keyContent = [System.IO.File]::ReadAllText(
            "$(Get-Location)\src-tauri\.tauri\myapp.key",
            [System.Text.Encoding]::UTF8
          )
          
          if ([string]::IsNullOrWhiteSpace($keyContent)) {
            echo "❌ Key file is empty!"
            exit 1
          }
          
          # Debug key lengths (without revealing content)
          echo "Original key length: $($env:TAURI_SIGNING_PRIVATE_KEY.Length)"
          echo "File key length: $($keyContent.Length)"
          
          echo "✅ Key file created and contains content"
          
          # Set the environment variable directly
          $env:TAURI_SIGNING_PRIVATE_KEY = $keyContent

      # Step 8: Build the final Tauri desktop application
      # This combines the client, server, and creates a Windows installer
      - name: 🏗️ Build Tauri with signing
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          CUSTOM_ENV: "car-components"
          NEXT_PUBLIC_APP_NAME: "Car Components"
          NEXT_PUBLIC_API_URL: "http://localhost:8000/v1"
        run: |
          # Verify environment variable
          if ([string]::IsNullOrWhiteSpace($env:TAURI_SIGNING_PRIVATE_KEY)) {
            echo "❌ TAURI_SIGNING_PRIVATE_KEY environment variable is not set!"
            exit 1
          }
          echo "✅ TAURI_SIGNING_PRIVATE_KEY environment variable is set"
          
          # Verify key file exists and matches
          $keyContent = [System.IO.File]::ReadAllText(
            "$(Get-Location)\src-tauri\.tauri\myapp.key",
            [System.Text.Encoding]::UTF8
          )
          
          # Debug lengths
          echo "Build step - Env key length: $($env:TAURI_SIGNING_PRIVATE_KEY.Length)"
          echo "Build step - File key length: $($keyContent.Length)"
          
          if ($keyContent -ne $env:TAURI_SIGNING_PRIVATE_KEY) {
            echo "❌ Key file content doesn't match environment variable!"
            echo "This might be due to line endings or encoding issues."
            exit 1
          }
          echo "✅ Key file content matches environment variable"
          
          # Continue with build
          node scripts/prepare-env.js          # Prepare environment variables
          node scripts/update-tauri-config.js  # Update Tauri configuration
          npx --yes @tauri-apps/cli build     # Build the final desktop app

      # Step 9: Extract signature for auto-updates
      # This extracts the signature file generated during the build process
      - name: 🪄 Extract .sig contents
        id: extract_sig
        run: |
          # Find the actual generated file version
          $GENERATED_FILE = Get-ChildItem "src-tauri/target/release/bundle/nsis/Car Components_*_x64-setup.exe.sig" | Select-Object -First 1
          if (-not $GENERATED_FILE) {
              echo "❌ No signature file found!"
              exit 1
          }
          $VERSION = [regex]::Match($GENERATED_FILE.Name, 'Car Components_(.+?)_x64-setup\.exe\.sig').Groups[1].Value
          echo "Found signature file with version: $VERSION"
          $SIG_PATH = $GENERATED_FILE.FullName
          echo "Full path: $SIG_PATH"
          # List contents of the directory to debug
          if (Test-Path "src-tauri/target/release/bundle/nsis") {
              Get-ChildItem "src-tauri/target/release/bundle/nsis"
          } else {
              echo "Directory src-tauri/target/release/bundle/nsis does not exist"
          }
          $SIG_CONTENT = Get-Content -Raw $SIG_PATH
          echo "sig=$SIG_CONTENT" >> $env:GITHUB_OUTPUT

      # Step 10: Generate update manifest
      # Creates latest.json which Tauri uses for auto-updates
      - name: 📝 Generate latest.json
        id: gen_manifest
        run: |
          $VERSION = node -p "require('./src-tauri/tauri.conf.json').version"
          $PUB_DATE = [DateTime]::UtcNow.ToString("yyyy-MM-ddTHH:mm:ssZ")
          $URL = "https://github.com/${{ github.repository }}/releases/download/v${VERSION}/Car.Components_${VERSION}_x64-setup.exe"
          
          $JSON = @{
            version = $VERSION
            notes = "Release v${VERSION}"
            pub_date = $PUB_DATE
            platforms = @{
              "windows-x86_64" = @{
                signature = "${{ steps.extract_sig.outputs.sig }}"
                url = $URL
              }
            }
          } | ConvertTo-Json -Depth 10
          
          Set-Content -Path latest.json -Value $JSON
          echo "version=$VERSION" >> $env:GITHUB_OUTPUT

      # Step 11: Create a new GitHub release
      # This creates a new release on GitHub with the current version
      - name: 🏷️ Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.gen_manifest.outputs.version }}
          release_name: Release v${{ steps.gen_manifest.outputs.version }}
          body: Automated release for version ${{ steps.gen_manifest.outputs.version }}
          draft: false
          prerelease: false

      # Step 12: Upload the Windows installer
      # This uploads the generated installer to the GitHub release
      - name: 📤 Upload EXE
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: src-tauri/target/release/bundle/nsis/Car Components_${{ steps.gen_manifest.outputs.version }}_x64-setup.exe
          asset_name: Car.Components_${{ steps.gen_manifest.outputs.version }}_x64-setup.exe
          asset_content_type: application/octet-stream

      # Step 13: Upload the update manifest
      # This uploads latest.json which enables auto-updates for users
      - name: 📤 Upload latest.json
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: latest.json
          asset_name: latest.json
          asset_content_type: application/json
